package giis.dashgit.updater.test;

import java.io.IOException;

import org.junit.Test;

import giis.dashgit.updater.DependencyUpdater;
import giis.dashgit.updater.DependencyUpdaterFacade;
import giis.qabot.ci.clients.GitLocal;
import giis.qabot.ci.clients.IGitClient;
import giis.qabot.ci.models.Project;
import giis.qabot.ci.models.PullRequest;
import giis.qabot.core.models.Formatter;
import lombok.extern.slf4j.Slf4j;

/**
 * A full IT scenario of dependency updates, including
 * - Aggregation of more than one update
 * - Conflicting updates (because of adjacent changes)
 *   - Conflict can be resolved automatically
 *   - Conflict can't be resolved (update should be excluded)
 * 
 * Requires a dedicated repository and configuration file:
 * 
 * - Configuration file must be named it.properties, placed at the root of this project.
 * - It must contain these keys:
 *   - github.server: the url of the repository (e.g. https://github.com)
 *   - github.repo: the full name of the test repository (in the form OWNER/REPO)
 *   - github.token: a token with write access to the test repository
 *   - github.user: the username that owns this token
 *   - github.email: the email of this username
 * - Add the workflow file that can be found in src/test/resources/git-project/github-ci.yml to the test repository
 *   (this workflow executes a script that will be pushed at the test setup)
 * - The test repository must have configured:
 *   - in Setup-General: Allow auto-merge, Automatically delete head branches
 *   - in Setup-branches: Create a branch protection rule for main, set Require status checks to pass before merging
 *     and indicate required status check is test (the job defined in github-ci.yml)
 *     
 * To test GitLab there is a subclass of this. Configuration requires:
 *  - The same keys in it.properties, but with the prefix gitlab instead of github.
 *  - The workflow file can be found in src/test/resources/git-project/.gitlab-ci.yml
 *  - No special configuration is required to allow auto-merge
 * To test GitLab on premises with jenkins:
 *  - Do not put the .gitlab-ci.yml
 *  - Instead, add the webhook to trigger the jenkins pipeline
 *  
 */
@Slf4j
public class TestItGithubLiveUpdates extends Base {

	protected DependencyUpdater updateService = new DependencyUpdater();
	protected Config config;

	// Override these methods to handle a different git provider
	
	protected Config setUpConfig() {
		return new Config().read("github");
	}

	/**
	 * Combined update process from a set of PRs, including setup and cleanup.
	 * Each branch i makes a change in a line.
	 * Because all changes are on adjacent lines, odd changes are potentially conflicting.
	 * A parameter is set to determine that this conflict can be automatically resolved or not.
	 * 
	 * Scenario 1 (conflict can't be solved)
	 * - update with no conflict
	 * - update with conflict can't be solved (exclude)
	 * - update with no conflict after excluded update
	 * Scenario 2 (conflict can be solved)
	 * - update with no conflict
	 * - update with conflict is solved
	 * - update with conflict generated by a previous conflict resolution
	 */
	private void runTestCombinedUpdates(boolean unresolvedConflict) throws IOException, InterruptedException {
		config = setUpConfig();
		IGitClient gitClient = config.getGitClient();
		Project project = super.getTestProject(config);

		cleanTestBranchesAndPrs(gitClient, project, rateLimitDelay);
		try (GitLocal gitLocal = config.getGitLocal()) {
			setupTestBranchesAndPrs(gitClient, gitLocal, project, unresolvedConflict);
		}
		// Here, we do not wait for build finish as we do not need to check the status
		// (this is left to the user)

		PullRequest combinedPr = null;
		try (GitLocal gitLocal = config.getGitLocal()) {
			combinedPr = updateService.runCreateCombinedProjectPr(gitClient, gitLocal, project, rateLimitDelay);
		}

		// Check status of all PRs and content
		log.debug("*** Check test results...");
		Thread.sleep(4000); // gives some time (I noted once that check for closed PRs was flaky)
		assertPristinePullRequestStatus(gitClient, new Formatter(), project, unresolvedConflict);
		assertCombinedPullRequestValues(gitClient, project, combinedPr, unresolvedConflict);
		assertCombinedPullRequestStatus(gitClient, project, combinedPr);
		// cleanup conflicting branch, only if test pass
		cleanTestBranchesAndPrs(gitClient, project, super.rateLimitDelay);
	}
	
	@Test
	public void testCombinedUpdatesUnresolvedConflict() throws IOException, InterruptedException {
		runTestCombinedUpdates(true);
	}
	
	@Test
	public void testCombinedUpdatesResolvedConflict() throws IOException, InterruptedException {
		runTestCombinedUpdates(false);
	}
	
	/**
	 * Uncomment the Test annotation to test manually the combined update given a
	 * project by full name and the PR internal ids
	 */
	// @Test
	public void testManualTemplate() {
		config = setUpConfig();
		IGitClient gitClient = config.getGitClient();
		try (GitLocal gitLocal = config.getGitLocal()) {
			new DependencyUpdaterFacade().mergeCombinedPullRequest(gitClient, gitLocal, 
					"*****/*****", new long[] { 1, 2, 3 }, 1000, false);
		}
	}
	
}
