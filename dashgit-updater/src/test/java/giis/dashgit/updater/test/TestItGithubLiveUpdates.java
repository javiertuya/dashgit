package giis.dashgit.updater.test;

import java.io.IOException;

import org.junit.Test;

import giis.dashgit.updater.DependencyUpdater;
import giis.dashgit.updater.DependencyUpdaterFacade;
import giis.qabot.ci.clients.GitLocal;
import giis.qabot.ci.clients.GithubGitClient;
import giis.qabot.ci.clients.IGitClient;
import giis.qabot.ci.models.Project;
import giis.qabot.ci.models.PullRequest;
import giis.qabot.core.models.Formatter;
import lombok.extern.slf4j.Slf4j;

/**
 * A full IT scenario of dependency updates, including
 * - Aggregation of more than one update
 * - Conflicting updates (because of adjacent changes)
 *   - Conflict can be resolved automatically
 *   - Conflict can't be resolved (update should be excluded)
 * 
 * Requires a dedicated repository and configuration file (see readme for configuration details).
 * 
 * This is the GitHub test, GitLab test uses a subclass of this.
 */
@Slf4j
public class TestItGithubLiveUpdates extends Base {

	protected DependencyUpdater updateService = new DependencyUpdater();
	protected Config config;

	// Override these methods to handle a different git provider
	
	protected Config setUpConfig() {
		return new Config().read("github");
	}

	protected IGitClient getGitClient() {
		return new GithubGitClient(config.server(), config.user(), config.token(), true);
	}

	protected GitLocal getGitLocal() {
		return new GitLocal("target", config.server(), config.user(), config.token());
	}

	/**
	 * Combined update process from a set of PRs, including setup and cleanup.
	 * Each branch i makes a change in a line.
	 * Because all changes are on adjacent lines, odd changes are potentially conflicting.
	 * A parameter is set to determine that this conflict can be automatically resolved or not.
	 * 
	 * Scenario 1 (conflict can't be solved)
	 * - update with no conflict
	 * - update with conflict can't be solved (exclude)
	 * - update with no conflict after excluded update
	 * Scenario 2 (conflict can be solved)
	 * - update with no conflict
	 * - update with conflict is solved
	 * - update with conflict generated by a previous conflict resolution
	 */
	private void runTestCombinedUpdates(boolean unresolvedConflict) throws IOException, InterruptedException {
		config = setUpConfig();
		IGitClient gitClient = getGitClient();
		Project project = super.getTestProject();
		project.name(config.repo());

		cleanTestBranchesAndPrs(gitClient, project, rateLimitDelay);
		try (GitLocal gitLocal = getGitLocal()) {
			setupTestBranchesAndPrs(gitClient, gitLocal, project, unresolvedConflict);
		}
		// Here, we do not wait for build finish as we do not need to check the status
		// (this is left to the user)

		PullRequest combinedPr = null;
		try (GitLocal gitLocal = getGitLocal()) {
			combinedPr = updateService.runCreateCombinedProjectPr(gitClient, gitLocal, project, rateLimitDelay);
		}

		// Check status of all PRs and content
		log.debug("*** Check test results...");
		Thread.sleep(4000); // gives some time (I noted once that check for closed PRs was flaky)
		assertPristinePullRequestStatus(gitClient, new Formatter(), project, unresolvedConflict);
		assertCombinedPullRequestValues(gitClient, project, combinedPr, unresolvedConflict);
		assertCombinedPullRequestStatus(gitClient, project, combinedPr);
		// cleanup conflicting branch, only if test pass
		cleanTestBranchesAndPrs(gitClient, project, super.rateLimitDelay);
	}
	
	@Test
	public void testCombinedUpdatesUnresolvedConflict() throws IOException, InterruptedException {
		runTestCombinedUpdates(true);
	}
	
	@Test
	public void testCombinedUpdatesResolvedConflict() throws IOException, InterruptedException {
		runTestCombinedUpdates(false);
	}
	
	/**
	 * Uncomment the Test annotation to test manually the combined update given a
	 * project by full name and the PR internal ids
	 */
	// @Test
	public void testManualTemplate() {
		config = setUpConfig();
		IGitClient gitClient = getGitClient();
		try (GitLocal gitLocal = getGitLocal()) {
			new DependencyUpdaterFacade().mergeCombinedPullRequest(gitClient, gitLocal, 
					"*****/*****", new long[] { 1, 2, 3 }, 1000);
		}
	}
	
}
